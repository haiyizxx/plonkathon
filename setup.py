from utils import *
import py_ecc.bn128 as b
from curve import ec_lincomb, G1Point, G2Point
from compiler.program import CommonPreprocessedInput
from verifier import VerificationKey
from dataclasses import dataclass
from poly import Polynomial, Basis

# Recover the trusted setup from a file in the format used in
# https://github.com/iden3/snarkjs#7-prepare-phase-2
# POS means postion in the file
SETUP_FILE_G1_STARTPOS = 80
SETUP_FILE_POWERS_POS = 60


@dataclass
class Setup(object):
    #   ([1]₁, [x]₁, ..., [x^{d-1}]₁)
    # = ( G,    xG,  ...,  x^{d-1}G ), where G is a generator of G_2
    powers_of_x: list[G1Point]
    # [x]₂ = xH, where H is a generator of G_2
    X2: G2Point

    @classmethod
    def from_file(cls, filename):
        contents = open(filename, "rb").read()
        # Byte 60 gives you the base-2 log of how many powers there are
        # 2048 powers
        powers = 2 ** contents[SETUP_FILE_POWERS_POS]

        # Extract G1 points, which start at byte 80
        values = [
            int.from_bytes(contents[i: i + 32], "little")
            for i in range(
                # 2: This factor accounts for the fact that each elliptic curve point consists of two coordinates: x and y.
                SETUP_FILE_G1_STARTPOS, SETUP_FILE_G1_STARTPOS + 32 * powers * 2, 32
            )
        ]
        # field modulus 21888242871839275222246405745257275088696311157297823662689037894645226208583
        assert max(values) < b.field_modulus

        # The points are encoded in a weird encoding, where all x and y points
        # are multiplied by a factor (for montgomery optimization?). We can
        # extract the factor because we know the first point is the generator.

        """
        G1 is the generator point of the elliptic curve over the finite field FQ
        It is a base point on the elliptic curve from which other points can be generated by scalar multiplication.
        G1 = (FQ(1), FQ(2))
        factor is 6350874878119819312338956282401532409788428879151445726012394534686998597021
        """
        factor = b.FQ(values[0]) / b.G1[0]
        values = [b.FQ(x) / factor for x in values]

        """
        (x, y) pairs
        It is a list of points on the G1 subgroup of the elliptic curve.
        The points are generated by scalar multiplication of the generator point G with increasing powers of x (G, xG, x^2G, ..., x^(d-1)G).
        """
        powers_of_x = [(values[i * 2], values[i * 2 + 1])
                       for i in range(powers)]

        # Search for start of G2 points. We again know that the first point is
        # the generator.
        pos = SETUP_FILE_G1_STARTPOS + 32 * powers * 2
        # coeffs: Points on elliptic curves in extension fields are often represented in terms of coefficients of their polynomial basis.
        # For instance, if the point is represented in a field F_(p^k), each coordinate of the point can be a polynomial of degree less than
        # k with coefficients in F_p.
        # coeffs[0]: This selects the first coefficient of the polynomial representing this point's coordinate.
        target = (factor * b.G2[0].coeffs[0]).n

        while pos < len(contents):
            v = int.from_bytes(contents[pos: pos + 32], "little")
            if v == target:
                break
            pos += 1
        print("Detected start of G2 side at byte {}".format(pos))

        X2_encoding = contents[pos + 32 * 4: pos + 32 * 8]
        """
        X^2 point values: [
            21831381940315734285607113342023901060522397560371972897001948545212302161822, 17231025384763736816414546592865244497437017442647097510447326538965263639101, 
            2388026358213174446665280700919698872609886601280537296205114254867301080648, 11507326595632554467052522095592665270651932854513688777769618397986436103170
        ]
        why X2_values only have 4 values?
        (x1 + x2 * i, y1 + y2 * i)
        """
        X2_values = [
            b.FQ(int.from_bytes(X2_encoding[i: i + 32], "little")) / factor
            for i in range(0, 128, 32)
        ]

        X2 = (b.FQ2(X2_values[:2]), b.FQ2(X2_values[2:]))
        assert b.is_on_curve(X2, b.b2)
        print("Extracted G2 side, X^1 point: {}".format(X2))
        assert b.pairing(b.G2, powers_of_x[1]) == b.pairing(X2, b.G1)
        print("X^1 points checked consistent")
        return cls(powers_of_x, X2)

    # Encodes the KZG commitment that evaluates to the given values in the group
    def commit(self, values: Polynomial) -> G1Point:
        assert values.basis == Basis.LAGRANGE

        # Run inverse FFT to convert values from Lagrange basis to monomial basis
        # 8 coeffs: [19152212512859365819465605027100115702479818850364030050735928663253832433665,..]
        monomial_coeffs = values.ifft().values

        # Optional: Check values size does not exceed maximum power setup can handle
        """
        The number of powers_of_x essentially defines the maximum degree d-1 
        
        The commitment to a polynomial p(x) is computed as linear combination of
        the points in power of x weighted by polynomial's coefficients.
        Commitment = c0*G + c1*xG + c2*x^2G + ... + c(d-1)*x^(d-1)G

        If there are more coefficients than points in powers_of_x, there wouldn’t be enough points to compute this linear combination
        """
        if len(monomial_coeffs) > len(self.powers_of_x):
            raise Exception("Not enough powers in setup")

        # Compute linear combination of setup with values
        """
        It then calculates the commitment by multiplying each coefficient of the polynomial by the corresponding power_of_x point,
        and summing the resulting points.
        This is essentially a scalar multiplication and point addition operation on the elliptic curve points.
        """
        return ec_lincomb([(s, x) for s, x in zip(self.powers_of_x, monomial_coeffs)])

    """
    The CommonPreprocessedInput is typically generated once for a specific program or computation,
    and can be reused by multiple provers and verifiers to create and verify zk-SNARK proofs.

    By preprocessing some parts of the computation, the time and computational complexity involved in generating and verifying proofs can be significantly reduced.
    """
    # Generate the verification key for this program with the given setup
    def verification_key(self, pk: CommonPreprocessedInput) -> VerificationKey:
        # Create the appropriate VerificationKey object
        return VerificationKey(
            group_order=pk.group_order,
            Qm=self.commit(pk.QM),
            Ql=self.commit(pk.QL),
            Qr=self.commit(pk.QR),
            Qo=self.commit(pk.QO),
            Qc=self.commit(pk.QC),
            S1=self.commit(pk.S1),
            S2=self.commit(pk.S2),
            S3=self.commit(pk.S3),
            X_2=self.X2,
            w=Scalar.root_of_unity(pk.group_order),
        )
