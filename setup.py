from utils import *
import py_ecc.bn128 as b
from curve import ec_lincomb, G1Point, G2Point
from compiler.program import CommonPreprocessedInput
from verifier import VerificationKey
from dataclasses import dataclass
from poly import Polynomial, Basis

# Recover the trusted setup from a file in the format used in
# https://github.com/iden3/snarkjs#7-prepare-phase-2
SETUP_FILE_G1_STARTPOS = 80
SETUP_FILE_POWERS_POS = 60


@dataclass
class Setup(object):
    #   ([1]₁, [x]₁, ..., [x^{d-1}]₁)
    # = ( G,    xG,  ...,  x^{d-1}G ), where G is a generator of G_2
    powers_of_x: list[G1Point]
    # [x]₂ = xH, where H is a generator of G_2
    X2: G2Point

    @classmethod
    def from_file(cls, filename):
        contents = open(filename, "rb").read()
        # Byte 60 gives you the base-2 log of how many powers there are
        powers = 2 ** contents[SETUP_FILE_POWERS_POS]
        # Extract G1 points, which start at byte 80
        values = [
            int.from_bytes(contents[i : i + 32], "little")
            for i in range(
                SETUP_FILE_G1_STARTPOS, SETUP_FILE_G1_STARTPOS + 32 * powers * 2, 32
            )
        ]
        assert max(values) < b.field_modulus
        # The points are encoded in a weird encoding, where all x and y points
        # are multiplied by a factor (for montgomery optimization?). We can
        # extract the factor because we know the first point is the generator.

        """
        G1 is the generator point of the elliptic curve over the finite field FQ
        It is a base point on the elliptic curve from which other points can be generated by scalar multiplication.
        G1 = (FQ(1), FQ(2))  -> G1 = (FQ(1), FQ(2))
        """
        factor = b.FQ(values[0]) / b.G1[0]
        values = [b.FQ(x) / factor for x in values]

        """
        (x, y) pairs
        It is a list of points on the G1 subgroup of the elliptic curve.
        The points are generated by scalar multiplication of the generator point G with increasing powers of x (G, xG, x^2G, ..., x^(d-1)G).
        """
        powers_of_x = [(values[i * 2], values[i * 2 + 1]) for i in range(powers)]
        print("Extracted G1 side, X^1 point: {}".format(powers_of_x[1]))

        # Search for start of G2 points. We again know that the first point is
        # the generator.
        pos = SETUP_FILE_G1_STARTPOS + 32 * powers * 2
        target = (factor * b.G2[0].coeffs[0]).n
        while pos < len(contents):
            v = int.from_bytes(contents[pos : pos + 32], "little")
            if v == target:
                break
            pos += 1
        print("Detected start of G2 side at byte {}".format(pos))
        X2_encoding = contents[pos + 32 * 4 : pos + 32 * 8]
        X2_values = [
            b.FQ(int.from_bytes(X2_encoding[i : i + 32], "little")) / factor
            for i in range(0, 128, 32)
        ]
        X2 = (b.FQ2(X2_values[:2]), b.FQ2(X2_values[2:]))
        assert b.is_on_curve(X2, b.b2)
        print("Extracted G2 side, X^1 point: {}".format(X2))
        assert b.pairing(b.G2, powers_of_x[1]) == b.pairing(X2, b.G1)
        print("X^1 points checked consistent")
        return cls(powers_of_x, X2)

    # Encodes the KZG commitment that evaluates to the given values in the group
    def commit(self, values: Polynomial) -> G1Point:
        assert values.basis == Basis.LAGRANGE

        # Run inverse FFT to convert values from Lagrange basis to monomial basis
        monomial_coeffs = values.inverse_fft()

        # Optional: Check values size does not exceed maximum power setup can handle
        if len(monomial_coeffs) <= len(self.powers_of_x):
            raise ValueError("Polynomial degree exceeds the maximum supported by the setup.")

        # Compute linear combination of setup with values
        """
        It then calculates the commitment by multiplying each coefficient of the polynomial by the corresponding power_of_x point,
        and summing the resulting points.
        This is essentially a scalar multiplication and point addition operation on the elliptic curve points.
        """
        return ec_lincomb([(s, x) for s, x in zip(self.powers_of_x, monomial_coeffs)])

    """
    The CommonPreprocessedInput is typically generated once for a specific program or computation,
    and can be reused by multiple provers and verifiers to create and verify zk-SNARK proofs.

    By preprocessing some parts of the computation, the time and computational complexity involved in generating and verifying proofs can be significantly reduced.
    """
    # Generate the verification key for this program with the given setup
    def verification_key(self, pk: CommonPreprocessedInput) -> VerificationKey:
        # Create the appropriate VerificationKey object
        return VerificationKey(
            group_order=pk.group_order,
            Qm=self.commit(pk.QM),
            Ql=self.commit(pk.QL),
            Qr=self.commit(pk.QR),
            Qo=self.commit(pk.QO),
            Qc=self.commit(pk.QC),
            S1=self.commit(pk.S1),
            S2=self.commit(pk.S2),
            S3=self.commit(pk.S3),
            X_2=self.X2,
            w=Scalar.root_of_unity(pk.group_order),
        )
